定期的に実行するコードクオリティチェックです。静的解析では検出できない設計上の問題を発見し、コードベースの健全性を維持します。

引数: `$ARGUMENTS` — チェック対象のスコープ（例: `src/stores/`, `src/lib/parsers/`）。省略時はプロジェクト全体を対象とする。

---

## 理念

このプロジェクトは「動けばよい」ではなく「正しく・簡潔に書く」を原則とする。Biome や TypeScript の静的チェックでは検出できない**設計品質**を人の目（とAIの目）で検証するのがこのチェックの目的である。

判断基準は常に「シンプルかどうか」であり「簡単かどうか」ではない。シンプルとは、各要素が1つの責務を持ち、組み合わせ可能で、理解しやすいことを意味する。コード量が少ないことや書くのが楽であることとは異なる。

---

## Phase 1: 自動チェックの実行

以下を**並列**で実行し、結果をまとめる。

1. `pnpm run typecheck` — 型エラー
2. `pnpm run lint` — lint / format エラー
3. `pnpm run test` — テスト結果

失敗がある場合は、Phase 2 以降の結果と合わせて最終レポートに含める。

## Phase 2: 単一責任の原則（SRP）チェック

Explore subagent を活用して対象スコープを調査する。

### 2-1. ファイルサイズと責務の分散

各ファイルの行数を調査し、以下の基準で評価する。

| 分類 | 行数目安 | 判定 |
|------|---------|------|
| lib/ モジュール | 〜200行 | 200行超で注意、300行超で要分割検討 |
| components/ | 〜150行 | 150行超で注意、250行超で要分割検討 |
| stores/ | 〜150行 | 150行超で注意、250行超で要分割検討 |
| types/ | 〜100行 | 制約なし（型定義は長くなりうる） |

行数はあくまで目安。**1ファイルが複数の責務を持っていないか**が本質的な判断基準。

### 2-2. 責務の混在検出

以下のパターンを探す:

- **コンポーネントにロジックが混入**: `src/components/` 内で複雑な計算・変換・条件分岐が直接記述されている
  - UI は表示に徹し、ロジックは `src/lib/` に、データ取得は `src/stores/` 経由であるべき
- **ストアにビジネスロジックが混入**: `src/stores/` 内でデータ変換や解析処理が直接実装されている
  - ストアは状態の保持と更新に徹し、ロジックは `src/lib/` に委譲すべき
- **1つの関数/メソッドが多すぎる処理を担当**: 30行を超える関数は分割を検討
- **God Object パターン**: 1つのファイルが多数の export を持ち、プロジェクト全体から参照されている

### 2-3. 型安全性パターン

- **`as` 型アサーションの使用**: `as const` と `as unknown` を除き、`as` による型アサーションが存在しないか
  - 外部データ（Worker からの postMessage、JSZip の展開結果など）の型付けは valibot スキーマによるバリデーションで担保すべき
  - `as` はコンパイラを黙らせるだけで実行時の安全性を保証しない
- **型ガードなしの `unknown` 使用**: `unknown` 型を受け取った後、適切な型ガードや valibot パースなしにアクセスしている箇所

## Phase 3: DRY 原則チェック

### 3-1. コードの重複

対象スコープ内で以下を探す:

- **類似した処理ブロック**: 同じパターンの条件分岐、ループ、変換処理が複数箇所に存在
- **類似した型定義**: ほぼ同じ構造の interface/type が別ファイルに定義されている
- **コピペの痕跡**: 変数名だけ異なる同一構造のコードブロック

### 3-2. 抽象化の過不足

- **抽象化不足**: 3箇所以上で使われる同一パターンが関数化されていない
- **過剰な抽象化**: 1箇所でしか使われないのに汎用化された関数・ユーティリティ
  - ただし、テスト容易性のための分離は正当な理由として認める

## Phase 4: 結合度チェック

### 4-1. レイヤー境界の遵守

CLAUDE.md の Architecture Pointers に基づき検証する:

- `src/components/` → `src/lib/` の**直接 import が存在しないか**（stores 経由であるべき）
- `src/lib/` → `src/stores/` や `src/components/` への**逆方向依存がないか**
- Worker 境界: メインスレッドとの通信が postMessage 経由に限定されているか

### 4-2. モジュール間の依存

- **循環依存**: モジュール A → B → A のような循環 import がないか
- **深い依存チェーン**: A → B → C → D → E のように4段階以上の依存がないか
- **不要な依存**: import しているが実際には使われていないモジュール

## Phase 5: テストカバレッジチェック

### 5-1. テスト存在の確認

- `src/lib/` 配下の**すべてのモジュール**に対応するテストが `tests/` に存在するか
- 新規追加されたモジュールにテストが書かれているか（git diff で確認）

### 5-2. テスト品質の確認

- テストが実装の内部構造に依存しすぎていないか（密結合テスト）
- 正常系だけでなく**異常系・境界値**のテストケースがあるか
- テスト名が何をテストしているか明確に表現しているか

## Phase 6: レポート出力

以下のフォーマットでレポートを出力する:

```
# コードクオリティレポート

## 対象スコープ
[チェック対象のパスとファイル数]

## 自動チェック結果
- typecheck: ✅ / ❌ [詳細]
- lint: ✅ / ❌ [詳細]
- test: ✅ / ❌ [詳細]

## 🔴 Critical — 設計上の重大な問題
1. [問題の要約]
   - 箇所: [ファイルパス:行番号]
   - 理由: [なぜ問題なのか]
   - 提案: [改善案]

## 🟡 Warning — 改善推奨
1. [問題の要約]
   - 箇所: [ファイルパス:行番号]
   - 理由: [なぜ問題なのか]
   - 提案: [改善案]

## 🟢 Info — 軽微な指摘
1. [問題の要約]
   - 箇所: [ファイルパス:行番号]
   - 提案: [改善案]

## 📊 統計サマリー
- 対象ファイル数: N
- 200行超のファイル: [一覧]
- テスト未作成のモジュール: [一覧]
- レイヤー境界違反: N件

## ✅ 良い点
- [健全な設計判断や改善された箇所]
```

### 分類基準

- **Critical**: アーキテクチャ違反（レイヤー境界破壊、循環依存）、責務の重大な混在、テスト不在の重要モジュール
- **Warning**: DRY 違反、ファイルサイズ超過、テスト品質の問題、過剰/過少な抽象化
- **Info**: 軽微な命名改善、より良いパターンの提案、リファクタリング候補

---

**重要**: すべての指摘にはファイルパスと行番号を含めること。根拠のない指摘は行わない。「なんとなく気になる」ではなく「なぜ問題なのか」を明確にすること。

**提案の質**: 筋の悪い実装を発見した場合、場当たり的なパッチを提案してはならない。根本原因を特定し、設計レベルでの改善を提案すること。「動くようにする」ではなく「正しい構造にする」ことを優先する。症状への対処ではなく、その症状を生んだ構造的原因に言及すること。
